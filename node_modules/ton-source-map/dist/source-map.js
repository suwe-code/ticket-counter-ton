"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findHighlevelLocations = findHighlevelLocations;
exports.findHighlevelLocationBySection = findHighlevelLocationBySection;
exports.findAssemblyInstructions = findAssemblyInstructions;
const assembly_mapping_1 = require("./assembly-mapping");
/**
 * Returns high-level location for given hash+offset pair.
 *
 * Hash and offset is a standard representation in TVM used by TVM logs and in emulator.
 *
 * @param sourceMap Source Map to find in
 * @param hash      Cell hash from logs or TVM
 * @param offset    offset in Cell from logs or TVM
 */
function findHighlevelLocations(sourceMap, hash, offset) {
    const instructionInfo = (0, assembly_mapping_1.findInstructionInfo)(sourceMap.assemblyMapping, hash, offset);
    if (!instructionInfo) {
        return [];
    }
    const [instructions, index] = instructionInfo;
    if (index === -1) {
        return [];
    }
    const instruction = instructions[index];
    if (!instruction || instruction.debugSections.length === 0) {
        return [];
    }
    return instruction.debugSections
        .map(section => findHighlevelLocationBySection(sourceMap, section))
        .filter(it => it !== undefined);
}
/**
 * Returns high-level location associated with given debug section.
 *
 * @param sourceMap Source Map to find in
 * @param section   Debug section to find
 */
function findHighlevelLocationBySection(sourceMap, section) {
    return sourceMap.highlevelMapping.locations.find(loc => loc.idx === section);
}
/**
 * Returns assembly instructions associated with given high-level source location.
 *
 * @param sourceMap Source Map to find in
 * @param file      Filepath to find
 * @param line      Line number to find
 * @param column    Column number to find
 */
function findAssemblyInstructions(sourceMap, file, line, column) {
    const matchedEntry = sourceMap.highlevelMapping.locations.find(loc => loc.loc.file === file && loc.loc.line === line && loc.loc.column === column);
    if (!matchedEntry) {
        return [];
    }
    const debugSection = matchedEntry.idx;
    return Object.entries(sourceMap.assemblyMapping.cells).flatMap(([, cell]) => {
        if (!cell)
            return [];
        const instrIndex = cell.instructions.findIndex(instr => instr.debugSections.some(section => section === debugSection));
        if (instrIndex === -1)
            return [];
        const firstInstr = cell.instructions[instrIndex];
        if (!firstInstr)
            return [];
        const instructions = [firstInstr];
        for (let i = instrIndex + 1; i < cell.instructions.length; i++) {
            const instr = cell.instructions[i];
            if (!instr || instr.debugSections.length > 0) {
                break;
            }
            instructions.push(instr);
        }
        return instructions;
    });
}
//# sourceMappingURL=source-map.js.map