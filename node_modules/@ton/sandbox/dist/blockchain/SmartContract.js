"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContract = exports.EmulationError = exports.TimeError = exports.GetMethodError = void 0;
exports.createShardAccount = createShardAccount;
exports.createEmptyShardAccount = createEmptyShardAccount;
exports.storeOutListExt = storeOutListExt;
exports.loadOutListExt = loadOutListExt;
const core_1 = require("@ton/core");
const ec_1 = require("../utils/ec");
const selector_1 = require("../utils/selector");
const deepcopy_1 = require("../utils/deepcopy");
const debugger_1 = require("../debugger");
function createShardAccount(args) {
    let wc = args.workchain ?? 0;
    let address = args.address ?? (0, core_1.contractAddress)(wc, { code: args.code, data: args.data });
    let balance = args.balance ?? 0n;
    return {
        account: {
            addr: address,
            storage: {
                lastTransLt: 0n,
                balance: { coins: balance },
                state: {
                    type: 'active',
                    state: {
                        code: args.code,
                        data: args.data,
                    },
                },
            },
            storageStats: {
                used: {
                    cells: 0n,
                    bits: 0n,
                },
                lastPaid: 0,
                duePayment: null,
                storageExtra: null,
            },
        },
        lastTransactionLt: 0n,
        lastTransactionHash: 0n,
    };
}
function createEmptyAccount(address) {
    return {
        addr: address,
        storage: {
            lastTransLt: 0n,
            balance: { coins: 0n },
            state: { type: 'uninit' },
        },
        storageStats: {
            used: { cells: 0n, bits: 0n },
            lastPaid: 0,
            storageExtra: null,
        },
    };
}
function createEmptyShardAccount(address) {
    return {
        account: createEmptyAccount(address),
        lastTransactionLt: 0n,
        lastTransactionHash: 0n,
    };
}
function preloadActionType(data) {
    if (data.remainingBits < 32) {
        return 'unknown';
    }
    const tag = data.preloadUint(32);
    /*
     * action_send_msg#0ec3c86d mode:(## 8)
     *   out_msg:^(MessageRelaxed Any) = OutAction;
     *
     * action_set_code#ad4de08e new_code:^Cell = OutAction;
     *
     * action_reserve_currency#36e6b809 mode:(## 8)
     *   currency:CurrencyCollection = OutAction;
     *
     * action_change_library#26fa1dd4 mode:(## 7)
     *   libref:LibRef = OutAction;
     *
     */
    switch (tag) {
        case 0x0ec3c86d:
            return 'sendMsg';
        case 0xad4de08e:
            return 'setCode';
        case 0x36e6b809:
            return 'reserve';
        case 0x26fa1dd4:
            return 'changeLibrary';
        default:
            return 'unknown';
    }
}
function storeActionExt(action) {
    if (action.type === 'malformed') {
        return (builder) => {
            builder.storeSlice(action.data.beginParse());
        };
    }
    return (0, core_1.storeOutAction)(action);
}
function storeOutListExt(actions) {
    const cell = actions.reduce((cell, action) => (0, core_1.beginCell)().storeRef(cell).store(storeActionExt(action)).endCell(), (0, core_1.beginCell)().endCell());
    return (builder) => {
        builder.storeSlice(cell.beginParse());
    };
}
// loadOutList from @ton/core, but with exception handling
function loadOutListExt(data) {
    const actions = [];
    while (data.remainingRefs) {
        const nextCell = data.loadRef();
        const dataOrig = data.clone();
        const dataCell = data.asCell();
        try {
            actions.push((0, core_1.loadOutAction)(data));
        }
        catch {
            const actionType = preloadActionType(dataOrig);
            actions.push({
                type: 'malformed',
                subtype: actionType,
                data: dataCell,
            });
        }
        data = nextCell.beginParse();
    }
    return actions.reverse();
}
const verbosityToExecutorVerbosity = {
    none: 'short',
    vm_logs: 'full',
    vm_logs_location: 'full_location',
    vm_logs_gas: 'full_location_gas',
    vm_logs_full: 'full_location_stack',
    vm_logs_verbose: 'full_location_stack_verbose',
};
class GetMethodError extends Error {
    exitCode;
    gasUsed;
    blockchainLogs;
    vmLogs;
    debugLogs;
    constructor(exitCode, gasUsed, blockchainLogs, vmLogs, debugLogs) {
        super(`Unable to execute get method. Got exit_code: ${exitCode}`);
        this.exitCode = exitCode;
        this.gasUsed = gasUsed;
        this.blockchainLogs = blockchainLogs;
        this.vmLogs = vmLogs;
        this.debugLogs = debugLogs;
    }
}
exports.GetMethodError = GetMethodError;
class TimeError extends Error {
    address;
    previousTxTime;
    currentTime;
    constructor(address, previousTxTime, currentTime) {
        super(`Cannot run a transaction on account ${address} at unix timestamp ${currentTime} because it already had a transaction executed on it at unix timestamp ${previousTxTime}`);
        this.address = address;
        this.previousTxTime = previousTxTime;
        this.currentTime = currentTime;
    }
}
exports.TimeError = TimeError;
class EmulationError extends Error {
    error;
    vmLogs;
    exitCode;
    blockchainLogs;
    debugLogs;
    constructor(error, vmLogs, exitCode, blockchainLogs, debugLogs) {
        let errMsg = `Error while executing transaction: ${error}`;
        if (exitCode !== undefined) {
            errMsg += `\nExit code: ${exitCode}`;
        }
        if (vmLogs !== undefined) {
            errMsg += `\nVM logs:\n${vmLogs}`;
        }
        if (blockchainLogs !== undefined) {
            errMsg += `\nBlockchain logs:\n${blockchainLogs}`;
        }
        if (debugLogs !== undefined) {
            errMsg += `\nDebug logs:\n${debugLogs}`;
        }
        super(errMsg);
        this.error = error;
        this.vmLogs = vmLogs;
        this.exitCode = exitCode;
        this.blockchainLogs = blockchainLogs;
        this.debugLogs = debugLogs;
    }
}
exports.EmulationError = EmulationError;
class SmartContract {
    address;
    blockchain;
    _account;
    parsedAccount;
    lastTxTime;
    _verbosity;
    _debug;
    constructor(shardAccount, blockchain) {
        this.address = shardAccount.account.addr;
        this._account = (0, core_1.beginCell)().store((0, core_1.storeShardAccount)(shardAccount)).endCell().toBoc().toString('base64');
        this.parsedAccount = shardAccount;
        this.lastTxTime = shardAccount.account?.storageStats.lastPaid ?? 0;
        this.blockchain = blockchain;
    }
    snapshot() {
        return (0, deepcopy_1.deepcopy)({
            address: this.address,
            account: this.account,
            lastTxTime: this.lastTxTime,
            verbosity: this._verbosity,
        });
    }
    loadFrom(snapshot) {
        if (!snapshot.address.equals(this.address)) {
            throw new Error('Wrong snapshot address');
        }
        this.account = (0, deepcopy_1.deepcopy)(snapshot.account);
        this.lastTxTime = snapshot.lastTxTime;
        this._verbosity = snapshot.verbosity === undefined ? undefined : { ...snapshot.verbosity };
    }
    get ec() {
        return (0, ec_1.extractEc)(this.account.account?.storage.balance.other ??
            core_1.Dictionary.empty(core_1.Dictionary.Keys.Uint(32), core_1.Dictionary.Values.BigVarUint(5)));
    }
    set ec(nv) {
        const acc = this.account;
        if (acc.account === undefined) {
            acc.account = createEmptyAccount(this.address);
        }
        acc.account.storage.balance.other = (0, ec_1.packEc)(Object.entries(nv).map(([k, v]) => [Number(k), v]));
        this.account = acc;
    }
    get balance() {
        return this.account.account?.storage.balance.coins ?? 0n;
    }
    set balance(v) {
        const acc = this.account;
        if (acc.account === undefined) {
            acc.account = createEmptyAccount(this.address);
        }
        acc.account.storage.balance.coins = v;
        this.account = acc;
    }
    get lastTransactionHash() {
        return this.account.lastTransactionHash;
    }
    get lastTransactionLt() {
        return this.account.lastTransactionLt;
    }
    get accountState() {
        return this.account.account?.storage.state;
    }
    get account() {
        if (this.parsedAccount === undefined) {
            this.parsedAccount = (0, core_1.loadShardAccount)(core_1.Cell.fromBase64(this._account).beginParse());
        }
        return this.parsedAccount;
    }
    set account(account) {
        this._account = (0, core_1.beginCell)().store((0, core_1.storeShardAccount)(account)).endCell().toBoc().toString('base64');
        this.parsedAccount = account;
        this.lastTxTime = account.account?.storageStats.lastPaid ?? 0;
    }
    static create(blockchain, args) {
        return new SmartContract(createShardAccount(args), blockchain);
    }
    static empty(blockchain, address) {
        return new SmartContract(createEmptyShardAccount(address), blockchain);
    }
    createCommonArgs(params) {
        const now = params?.now ?? this.blockchain.now ?? Math.floor(Date.now() / 1000);
        if (now < this.lastTxTime) {
            throw new TimeError(this.address, this.lastTxTime, now);
        }
        return {
            config: this.blockchain.configBase64,
            libs: this.blockchain.libs ?? null,
            verbosity: verbosityToExecutorVerbosity[this.verbosity.vmLogs],
            shardAccount: this._account,
            now,
            lt: this.blockchain.lt,
            randomSeed: params?.randomSeed ?? this.blockchain.random ?? Buffer.alloc(32),
            ignoreChksig: params?.ignoreChksig ?? false,
            debugEnabled: this.verbosity.debugLogs,
            prevBlocksInfo: this.blockchain.prevBlocks,
        };
    }
    async receiveMessage(message, params, callStack) {
        const args = {
            ...this.createCommonArgs(params),
            message: (0, core_1.beginCell)().store((0, core_1.storeMessage)(message)).endCell(),
        };
        if (this.debug) {
            const debugContext = (0, debugger_1.getDebugContext)();
            const { uninitialized, debugInfo } = debugContext.getDebugInfo(this.account);
            if (debugInfo !== undefined) {
                const executor = await this.blockchain.getDebuggerExecutor();
                return await this.runCommon(() => debugContext.debugTransaction(executor, args, debugInfo), callStack);
            }
            else if (uninitialized) {
                // eslint-disable-next-line no-console
                console.log('Debugging uninitialized accounts is unsupported in debugger beta');
            }
        }
        return await this.runCommon(() => this.blockchain.executor.runTransaction(args), callStack);
    }
    async runTickTock(which, params) {
        return await this.runCommon(() => this.blockchain.executor.runTickTock({
            ...this.createCommonArgs(params),
            which,
        }));
    }
    async runCommon(run, callStack) {
        let oldStorage = undefined;
        if (this.blockchain.recordStorage && this.account.account?.storage.state.type === 'active') {
            oldStorage = this.account.account?.storage.state.state.data ?? undefined;
        }
        const res = await run();
        if (this.verbosity.print && this.verbosity.blockchainLogs && res.logs.length > 0) {
            // eslint-disable-next-line no-console
            console.log(res.logs);
        }
        if (!res.result.success) {
            throw new EmulationError(res.result.error, res.result.vmResults?.vmLog, res.result.vmResults?.vmExitCode, res.logs.length === 0 ? undefined : res.logs, res.debugLogs.length === 0 ? undefined : res.debugLogs);
        }
        if (this.verbosity.print && this.verbosity.vmLogs !== 'none' && res.result.vmLog.length > 0) {
            // eslint-disable-next-line no-console
            console.log(res.result.vmLog);
        }
        if (this.verbosity.print && this.verbosity.debugLogs && res.debugLogs.length > 0) {
            // eslint-disable-next-line no-console
            console.log(res.debugLogs);
        }
        const tx = (0, core_1.loadTransaction)(core_1.Cell.fromBase64(res.result.transaction).beginParse());
        this._account = res.result.shardAccount;
        this.parsedAccount = undefined;
        this.lastTxTime = tx.now;
        let newStorage = undefined;
        if (this.blockchain.recordStorage && this.account.account?.storage.state.type === 'active') {
            newStorage = this.account.account?.storage.state.state.data ?? undefined;
        }
        let outActions = undefined;
        if (res.result.actions) {
            outActions = loadOutListExt(core_1.Cell.fromBase64(res.result.actions).beginParse());
        }
        return {
            ...tx,
            blockchainLogs: res.logs,
            vmLogs: res.result.vmLog,
            debugLogs: res.debugLogs,
            callStack,
            oldStorage,
            newStorage,
            outActions,
        };
    }
    async get(method, stack = [], params) {
        if (this.account.account?.storage.state.type !== 'active') {
            throw new Error('Trying to run get method on non-active contract');
        }
        const args = {
            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
            code: this.account.account?.storage.state.state.code,
            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
            data: this.account.account?.storage.state.state.data,
            methodId: typeof method === 'string' ? (0, selector_1.getSelectorForMethod)(method) : method,
            stack,
            config: this.blockchain.configBase64,
            verbosity: verbosityToExecutorVerbosity[this.verbosity.vmLogs],
            libs: this.blockchain.libs,
            address: this.address,
            unixTime: params?.now ?? this.blockchain.now ?? Math.floor(Date.now() / 1000),
            balance: this.balance,
            randomSeed: params?.randomSeed ?? this.blockchain.random ?? Buffer.alloc(32),
            gasLimit: params?.gasLimit ?? 10000000n,
            debugEnabled: this.verbosity.debugLogs,
            extraCurrency: this.ec,
            prevBlocksInfo: this.blockchain.prevBlocks,
        };
        let res;
        if (this.debug) {
            const debugContext = (0, debugger_1.getDebugContext)();
            const { uninitialized, debugInfo } = debugContext.getDebugInfo(this.account);
            if (debugInfo !== undefined) {
                const executor = await this.blockchain.getDebuggerExecutor();
                res = await debugContext.debugGetMethod(executor, args, debugInfo);
            }
            else {
                if (uninitialized) {
                    // eslint-disable-next-line no-console
                    console.log('Debugging uninitialized accounts is unsupported in debugger beta');
                }
                res = await this.blockchain.executor.runGetMethod(args);
            }
        }
        else {
            res = await this.blockchain.executor.runGetMethod(args);
        }
        if (this.verbosity.print && this.verbosity.blockchainLogs && res.logs.length > 0) {
            // eslint-disable-next-line no-console
            console.log(res.logs);
        }
        if (!res.output.success) {
            throw new Error('Error invoking get method: ' + res.output.error);
        }
        if (this.verbosity.print && this.verbosity.vmLogs !== 'none' && res.output.vm_log.length > 0) {
            // eslint-disable-next-line no-console
            console.log(res.output.vm_log);
        }
        if (this.verbosity.print && this.verbosity.debugLogs && res.debugLogs.length > 0) {
            // eslint-disable-next-line no-console
            console.log(res.debugLogs);
        }
        if (res.output.vm_exit_code !== 0 && res.output.vm_exit_code !== 1) {
            throw new GetMethodError(res.output.vm_exit_code, BigInt(res.output.gas_used), res.logs, res.output.vm_log, res.debugLogs);
        }
        const resStack = (0, core_1.parseTuple)(core_1.Cell.fromBase64(res.output.stack));
        return {
            stack: resStack,
            stackReader: new core_1.TupleReader(resStack),
            exitCode: res.output.vm_exit_code,
            gasUsed: BigInt(res.output.gas_used),
            blockchainLogs: res.logs,
            vmLogs: res.output.vm_log,
            debugLogs: res.debugLogs,
        };
    }
    get verbosity() {
        return {
            ...this.blockchain.verbosity,
            ...this._verbosity,
        };
    }
    set verbosity(value) {
        this.setVerbosity(value);
    }
    setVerbosity(verbosity) {
        if (typeof verbosity === 'string') {
            this._verbosity = {
                ...this._verbosity,
                vmLogs: verbosity,
                blockchainLogs: verbosity !== 'none',
            };
        }
        else {
            this._verbosity = verbosity;
        }
    }
    get debug() {
        return this._debug ?? this.blockchain.debug;
    }
    setDebug(debug) {
        this._debug = debug;
    }
}
exports.SmartContract = SmartContract;
