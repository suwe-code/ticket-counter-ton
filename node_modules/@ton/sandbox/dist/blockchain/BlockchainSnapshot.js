"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blockIdToSerializable = blockIdToSerializable;
exports.snapshotToSerializable = snapshotToSerializable;
exports.snapshotFromSerializable = snapshotFromSerializable;
const core_1 = require("@ton/core");
const SmartContract_1 = require("./SmartContract");
const Event_1 = require("../event/Event");
function blockIdToSerializable(blockId) {
    return {
        workchain: blockId.workchain,
        shard: blockId.shard.toString(),
        seqno: blockId.seqno,
        rootHash: blockId.rootHash.toString('hex'),
        fileHash: blockId.fileHash.toString('hex'),
    };
}
function writableToBase64(writer) {
    return (0, core_1.beginCell)().store(writer).endCell().toBoc().toString('base64');
}
function snapshotToSerializable(snapshot) {
    return {
        contracts: snapshot.contracts.map((contract) => ({
            account: writableToBase64((0, core_1.storeShardAccount)(contract.account)),
            address: contract.address.toString(),
            lastTxTime: contract.lastTxTime,
            verbosity: contract.verbosity,
        })),
        networkConfig: snapshot.networkConfig,
        lt: snapshot.lt.toString(),
        time: snapshot.time,
        verbosity: snapshot.verbosity,
        libs: snapshot.libs?.toBoc().toString('base64'),
        nextCreateWalletIndex: snapshot.nextCreateWalletIndex,
        prevBlocksInfo: snapshot.prevBlocksInfo
            ? {
                lastMcBlocks: snapshot.prevBlocksInfo.lastMcBlocks.map(blockIdToSerializable),
                prevKeyBlock: blockIdToSerializable(snapshot.prevBlocksInfo.prevKeyBlock),
                lastMcBlocks100: snapshot.prevBlocksInfo.lastMcBlocks100?.map(blockIdToSerializable),
            }
            : undefined,
        randomSeed: snapshot.randomSeed?.toString('hex'),
        autoDeployLibs: snapshot.autoDeployLibs,
        transactions: snapshot.transactions.map((transaction) => {
            return {
                transaction: writableToBase64((0, core_1.storeTransaction)(transaction)),
                blockchainLogs: transaction.blockchainLogs,
                vmLogs: transaction.vmLogs,
                debugLogs: transaction.debugLogs,
                oldStorage: transaction.oldStorage?.toBoc().toString('base64'),
                newStorage: transaction.newStorage?.toBoc().toString('base64'),
                outActions: transaction.outActions
                    ? writableToBase64((0, SmartContract_1.storeOutListExt)(transaction.outActions))
                    : undefined,
                externals: transaction.externals.map((external) => writableToBase64((0, core_1.storeMessageRelaxed)(external))),
                mode: transaction.mode,
                parentHash: transaction.parent?.hash().toString('hex'),
                childrenHashes: transaction.children.map((tx) => tx.hash().toString('hex')),
            };
        }),
    };
}
function blockIdFromSerializable(s) {
    return {
        workchain: s.workchain,
        shard: BigInt(s.shard),
        seqno: s.seqno,
        rootHash: Buffer.from(s.rootHash, 'hex'),
        fileHash: Buffer.from(s.fileHash, 'hex'),
    };
}
function snapshotFromSerializable(serialized) {
    const transactions = serialized.transactions.map((t) => {
        const transaction = (0, core_1.loadTransaction)(core_1.Cell.fromBase64(t.transaction).beginParse());
        return {
            ...transaction,
            blockchainLogs: t.blockchainLogs,
            vmLogs: t.vmLogs,
            debugLogs: t.debugLogs,
            oldStorage: t.oldStorage ? core_1.Cell.fromBase64(t.oldStorage) : undefined,
            newStorage: t.newStorage ? core_1.Cell.fromBase64(t.newStorage) : undefined,
            outActions: t.outActions ? (0, SmartContract_1.loadOutListExt)(core_1.Cell.fromBase64(t.outActions).beginParse()) : undefined,
            events: (0, Event_1.extractEvents)(transaction),
            mode: t.mode,
            externals: t.externals.map((ext) => (0, core_1.loadMessageRelaxed)(core_1.Cell.fromBase64(ext).beginParse())),
            children: [],
        };
    });
    const transactionsMap = new Map(transactions.map((tx) => [tx.hash().toString('hex'), tx]));
    for (let i = 0; i < transactions.length; i++) {
        const { parentHash, childrenHashes } = serialized.transactions[i];
        transactions[i].parent = parentHash ? transactionsMap.get(parentHash) : undefined;
        transactions[i].children = childrenHashes.map((hash) => transactionsMap.get(hash));
    }
    return {
        contracts: serialized.contracts.map((contract) => ({
            address: core_1.Address.parse(contract.address),
            account: (0, core_1.loadShardAccount)(core_1.Cell.fromBase64(contract.account).beginParse()),
            lastTxTime: contract.lastTxTime,
            verbosity: contract.verbosity,
        })),
        networkConfig: serialized.networkConfig,
        lt: BigInt(serialized.lt),
        time: serialized.time,
        verbosity: serialized.verbosity,
        libs: serialized.libs ? core_1.Cell.fromBase64(serialized.libs) : undefined,
        nextCreateWalletIndex: serialized.nextCreateWalletIndex,
        prevBlocksInfo: serialized.prevBlocksInfo
            ? {
                lastMcBlocks: serialized.prevBlocksInfo.lastMcBlocks.map(blockIdFromSerializable),
                prevKeyBlock: blockIdFromSerializable(serialized.prevBlocksInfo.prevKeyBlock),
                lastMcBlocks100: serialized.prevBlocksInfo.lastMcBlocks100?.map(blockIdFromSerializable),
            }
            : undefined,
        randomSeed: serialized.randomSeed ? Buffer.from(serialized.randomSeed, 'hex') : undefined,
        autoDeployLibs: serialized.autoDeployLibs,
        transactions,
    };
}
