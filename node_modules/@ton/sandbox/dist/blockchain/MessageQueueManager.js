"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageQueueManager = void 0;
const core_1 = require("@ton/core");
const Event_1 = require("../event/Event");
class MessageQueueManager {
    lock;
    blockchain;
    messageQueue = [];
    constructor(lock, blockchain) {
        this.lock = lock;
        this.blockchain = blockchain;
    }
    async pushMessage(message) {
        const msg = message instanceof core_1.Cell ? (0, core_1.loadMessage)(message.beginParse()) : message;
        if (msg.info.type === 'external-out') {
            throw new Error('Cannot send external out message');
        }
        await this.lock.with(async () => {
            this.messageQueue.push({
                type: 'message',
                ...msg,
            });
        });
    }
    async pushTickTock(on, which) {
        await this.lock.with(async () => {
            this.messageQueue.push({
                type: 'ticktock',
                on,
                which,
            });
        });
    }
    async runQueue(params) {
        const txes = await this.processQueue(params);
        return {
            transactions: txes,
            events: txes.map((tx) => tx.events).flat(),
            externals: txes.map((tx) => tx.externals).flat(),
        };
    }
    runQueueIter(needsLocking, params) {
        const it = {
            next: () => this.processTx(needsLocking, params),
            [Symbol.asyncIterator]() {
                return it;
            },
        };
        return it;
    }
    async processTx(needsLocking, params) {
        // Lock only if not locked already
        return needsLocking
            ? await this.lock.with(async () => this.processMessage(params))
            : await this.processMessage(params);
    }
    async processQueue(params) {
        const results = await this.lock.with(async () => {
            // Locked already
            const txs = this.runQueueIter(false, params);
            const result = [];
            for await (const tx of txs) {
                result.push(tx);
            }
            return result;
        });
        this.blockchain.onTransactions(results);
        return results;
    }
    async processMessage(params) {
        let result = undefined;
        let done = this.messageQueue.length == 0;
        while (!done) {
            const message = this.messageQueue.shift();
            let callStack;
            let tx;
            let smartContract;
            if (message.type === 'message') {
                callStack = message.callStack;
                if (message.info.type === 'external-out') {
                    done = this.messageQueue.length == 0;
                    continue;
                }
                this.blockchain.increaseLt();
                smartContract = await this.blockchain.getContract(message.info.dest);
                tx = await smartContract.receiveMessage(message, params, callStack);
            }
            else {
                this.blockchain.increaseLt();
                smartContract = await this.blockchain.getContract(message.on);
                tx = await smartContract.runTickTock(message.which, params);
            }
            const transaction = {
                ...tx,
                events: (0, Event_1.extractEvents)(tx),
                parent: message.parentTransaction,
                children: [],
                externals: [],
                mode: message.type === 'message' ? message.mode : undefined,
            };
            transaction.parent?.children.push(transaction);
            this.blockchain.onTransaction(transaction);
            result = transaction;
            done = true;
            const sendMsgActions = (transaction.outActions?.filter((action) => action.type === 'sendMsg') ??
                []);
            for (const [index, message] of transaction.outMessages) {
                if (message.info.type === 'external-out') {
                    transaction.externals.push({
                        info: {
                            type: 'external-out',
                            src: message.info.src,
                            dest: message.info.dest ?? undefined,
                            createdAt: message.info.createdAt,
                            createdLt: message.info.createdLt,
                        },
                        init: message.init ?? undefined,
                        body: message.body,
                    });
                    continue;
                }
                this.messageQueue.push({
                    type: 'message',
                    parentTransaction: transaction,
                    mode: sendMsgActions[index]?.mode,
                    callStack,
                    ...message,
                });
                if (message.info.type === 'internal') {
                    this.blockchain.startFetchingContract(message.info.dest);
                }
            }
            const isMasterchain = smartContract.account?.account?.addr.workChain === -1;
            if (isMasterchain && this.blockchain.getAutoDeployLibs()) {
                this.blockchain.setLibs(this.applyLibraryActions(this.blockchain.getLibs(), transaction?.outActions));
            }
        }
        return result === undefined ? { value: result, done: true } : { value: result, done: false };
    }
    applyLibraryActions(originalLibraries, outActions) {
        if (!outActions) {
            return originalLibraries;
        }
        const changeLibraryActions = outActions.filter((action) => action.type === 'changeLibrary');
        if (changeLibraryActions.length === 0) {
            return originalLibraries;
        }
        const keyType = core_1.Dictionary.Keys.Buffer(32);
        const valueType = core_1.Dictionary.Values.Cell();
        const libsDict = originalLibraries?.beginParse().loadDictDirect(keyType, valueType) ?? core_1.Dictionary.empty(keyType, valueType);
        for (const action of changeLibraryActions) {
            let { mode, libRef } = action;
            mode &= ~16;
            if (mode === 0) {
                // eslint-disable-next-line no-console
                console.warn('Removing libraries not supported');
            }
            else if (mode === 1) {
                // eslint-disable-next-line no-console
                console.warn('Private libraries are not supported');
            }
            else if (mode === 2) {
                if (libRef.type !== 'ref') {
                    throw new Error('When deploying a library, libRef should be a cell, not a hash');
                }
                const { library } = libRef;
                libsDict.set(library.hash(), library);
            }
            else {
                throw new Error(`Unknown changeLibraryAction mode ${mode}`);
            }
        }
        if (libsDict.keys().length === 0) {
            return originalLibraries;
        }
        return (0, core_1.beginCell)().storeDictDirect(libsDict).endCell();
    }
}
exports.MessageQueueManager = MessageQueueManager;
