"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MnemonicProvider = void 0;
const core_1 = require("@ton/core");
const crypto_1 = require("@ton/crypto");
const wallets_1 = require("./wallets");
class MnemonicProvider {
    constructor(params) {
        if (!(params.version in wallets_1.wallets)) {
            throw new Error(`Unknown wallet version ${params.version}, expected one of ${Object.keys(wallets_1.wallets).join(', ')}`);
        }
        this.client = params.client;
        this.network = params.network;
        const kp = (0, crypto_1.keyPairFromSecretKey)(params.secretKey);
        this.wallet = (0, core_1.openContract)(this.createWallet(params, kp), (params) => this.client.provider(params.address, params.init && {
            ...params.init,
            data: params.init.data ?? undefined,
            code: params.init.code ?? undefined,
        }));
        this.secretKey = kp.secretKey;
        this.ui = params.ui;
    }
    createWallet(params, kp) {
        if (params.version === 'v5r1') {
            return wallets_1.wallets[params.version].create({
                publicKey: kp.publicKey,
                walletId: {
                    networkGlobalId: params.network === 'testnet' ? -3 : -239, // networkGlobalId: -3 for Testnet, -239 for Mainnet
                    context: {
                        workchain: params.workchain ?? 0,
                        subwalletNumber: params.subwalletNumber ?? 0,
                        walletVersion: 'v5r1',
                    },
                },
            });
        }
        return wallets_1.wallets[params.version].create({
            workchain: params.workchain ?? 0,
            publicKey: kp.publicKey,
            walletId: params.walletId,
        });
    }
    async connect() {
        const formattedAddress = this.address().toString({
            testOnly: this.network === 'testnet',
            bounceable: false,
        });
        this.ui.write(`Connected to wallet at address: ${formattedAddress}\n`);
    }
    async sendTransaction(address, amount, payload, stateInit) {
        await this.wallet.sendTransfer({
            seqno: await this.wallet.getSeqno(),
            secretKey: this.secretKey,
            messages: [
                {
                    init: stateInit,
                    body: payload ?? new core_1.Cell(),
                    info: {
                        type: 'internal',
                        ihrDisabled: true,
                        ihrFee: 0n,
                        bounce: true,
                        bounced: false,
                        dest: address,
                        value: { coins: amount },
                        forwardFee: 0n,
                        createdAt: 0,
                        createdLt: 0n,
                    },
                },
            ],
            sendMode: core_1.SendMode.PAY_GAS_SEPARATELY,
        });
        this.ui.write('Sent transaction');
    }
    address() {
        return this.wallet.address;
    }
}
exports.MnemonicProvider = MnemonicProvider;
