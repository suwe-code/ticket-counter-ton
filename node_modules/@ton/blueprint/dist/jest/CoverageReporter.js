"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = __importDefault(require("node:path"));
const promises_1 = __importDefault(require("node:fs/promises"));
const fs_1 = require("fs");
const core_1 = require("@ton/core");
// @ts-expect-error blueprint imported inside package
const blueprint_1 = require("@ton/blueprint");
const sandbox_1 = require("@ton/sandbox");
const chalk_1 = __importDefault(require("chalk"));
class CoverageReporter {
    constructor() {
        this.contracts = [];
    }
    get coverageDir() {
        return node_path_1.default.join(process.cwd(), 'coverage');
    }
    get blueprintCoverageDir() {
        return node_path_1.default.join(this.coverageDir, 'blueprint');
    }
    async onRunStart() {
        console.log(`\nðŸ› ï¸  Building contracts...`);
        await (0, blueprint_1.buildAll)();
        const buildDir = node_path_1.default.join(process.cwd(), 'build');
        const buildFiles = (await promises_1.default.readdir(buildDir)).filter((f) => f.endsWith('.json'));
        const contents = await Promise.all(buildFiles.map((f) => promises_1.default.readFile(node_path_1.default.join(buildDir, f), 'utf-8')));
        this.contracts = contents.map((json, i) => ({
            name: node_path_1.default.basename(buildFiles[i], '.compiled.json'),
            ...JSON.parse(json),
        }));
        console.log(`âœ… Built ${this.contracts.length} contracts: ${this.contracts.map((c) => c.name).join(', ')}`);
        if ((0, fs_1.existsSync)(this.blueprintCoverageDir)) {
            console.log(`ðŸ§¹ Cleaning old coverage at ${this.blueprintCoverageDir}`);
            await promises_1.default.rm(this.blueprintCoverageDir, { recursive: true, force: true });
        }
    }
    async onRunComplete() {
        if (!(0, fs_1.existsSync)(this.blueprintCoverageDir)) {
            console.log(`âš ï¸  No blueprint coverage data found, skipping coverage reports.`);
            return;
        }
        console.log(`\nðŸ“„ Collecting coverage logs...`);
        const logs = await this.collectLogs();
        console.log(`\nðŸ“ Generating coverage reports...`);
        for (const { name, hex } of this.contracts) {
            const codeCell = core_1.Cell.fromHex(hex);
            const merged = (0, sandbox_1.mergeCoverages)(...logs.map((l) => (0, sandbox_1.collectAsmCoverage)(codeCell, l)));
            const coverage = new sandbox_1.Coverage(merged);
            const report = coverage.report('html');
            const reportPath = node_path_1.default.join(this.coverageDir, `${name}-report.html`);
            await promises_1.default.writeFile(reportPath, report);
            const summary = coverage.summary();
            this.printSummary(name, summary, reportPath);
        }
        console.log(`\nâœ… Coverage reports generated in ${this.coverageDir}\n`);
    }
    printSummary(name, summary, reportPath) {
        const pct = summary.coveragePercentage.toFixed(2) + '%';
        const line = chalk_1.default.bold(name.padEnd(20)) +
            chalk_1.default.white(`${summary.coveredLines}/${summary.totalLines} lines`.padEnd(20)) +
            (summary.coveragePercentage >= 80 ? chalk_1.default.green(pct.padEnd(10)) : chalk_1.default.red(pct.padEnd(10))) +
            chalk_1.default.gray(reportPath);
        console.log('   â€¢ ' + line);
    }
    async collectLogs() {
        const files = (await promises_1.default.readdir(this.blueprintCoverageDir, { recursive: true })).filter((f) => f.endsWith('.json'));
        const contents = await Promise.all(files.map((f) => promises_1.default.readFile(node_path_1.default.join(this.blueprintCoverageDir, f), 'utf-8')));
        return contents.flatMap((content) => {
            const { txLogs, getLogs } = JSON.parse(content);
            return [...txLogs, ...getLogs];
        });
    }
}
exports.default = CoverageReporter;
