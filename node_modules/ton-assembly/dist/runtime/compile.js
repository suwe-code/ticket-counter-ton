"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileInstructions = void 0;
const c = __importStar(require("./constructors"));
const $ = __importStar(require("./util"));
const builder_1 = require("./builder");
const instr_1 = require("./instr");
const layout_1 = require("./layout");
const types_1 = require("./types");
function isLastInstruction(index, instructions) {
    if (index === instructions.length - 1) {
        return true;
    }
    if (instructions[index + 1]?.$ !== "DEBUGMARK") {
        // Fast path, if:
        // POPCTR
        // ADD
        //
        // instruction is not the last one
        return false;
    }
    // if:
    // POPCTR
    // DEBUGMARK
    //
    // check that all remaining instructions are DEBUGMARK
    for (let i = index + 1; i < instructions.length; i++) {
        const instruction = instructions[i];
        if (instruction?.$ !== "DEBUGMARK") {
            // found non DEBUGMARK instruction in the tail, so instruction is not a last
            return false;
        }
    }
    return true;
}
const compileInstructions = (b, instructions, options) => {
    for (let index = 0; index < instructions.length; index++) {
        const instruction = instructions[index];
        if (!instruction)
            break;
        const builderBefore = new builder_1.CodeBuilder().storeBuilder(b);
        const isLast = isLastInstruction(index, instructions);
        const overflow = safeStore(b, instruction, isLast, options);
        if (!overflow) {
            // fast path
            continue;
        }
        // Handle case where instructions don't fit to the current cell.
        // In many cases, this happens at the if-else boundary, when the body
        // specified via PUSHCONT takes up a large number of bits. In this case, we
        // need to create a new ref and continue compiling the remaining instructions
        // into this ref
        const remainingInstructions = instructions.slice(index);
        // But we can try to optimize code like this:
        // ref {
        //   PUSHCONT { ... }
        //   IF
        //   ...
        // }
        // ->
        // IFREF { ... }
        // ...
        const match = (0, layout_1.matchingRule)(remainingInstructions);
        if (match && builderBefore.canFit(/* IFREF length */ 16)) {
            const instr = match.rule.ctor(match.body);
            match.rule.type.store(builderBefore, instr, options);
            b.reinitFrom(builderBefore);
            index++; // advance to not store instruction once again
            // All instructions after PUSHCONT + IF will be compiled in the current cell and
            // placed in a new cell if necessary.
            continue;
        }
        // Create a new ref and compile the remaining instruction to it
        $.PSEUDO_PUSHREF_ALWAYS.store(builderBefore, c.PSEUDO_PUSHREF($.code(remainingInstructions)), options);
        b.reinitFrom(builderBefore);
        // All remaining instructions already processed in PSEUDO_PUSHREF,
        // so we need to return here
        return;
    }
};
exports.compileInstructions = compileInstructions;
const compilePushcont = (b, code, loc, options) => {
    const b2 = new builder_1.CodeBuilder();
    types_1.PUSHCONT.store(b2, {
        $: "PUSHCONT",
        arg0: code,
        loc,
    }, options);
    const pushcontWithoutCodeWidth = 16;
    if (b2.bits - pushcontWithoutCodeWidth > 15) {
        types_1.PUSHCONT.store(b, {
            $: "PUSHCONT",
            arg0: code,
            loc,
        }, options);
    }
    else {
        types_1.PUSHCONT_SHORT.store(b, {
            $: "PUSHCONT_SHORT",
            arg0: code,
            loc,
        }, options);
    }
};
const compileNonRefIf = (b, instr, options) => {
    if (instr.$ === "IFREF") {
        types_1.IF.store(b, {
            $: "IF",
            loc: instr.loc,
        }, options);
    }
    if (instr.$ === "IFREFELSE" || instr.$ === "IFELSEREF") {
        types_1.IFELSE.store(b, {
            $: "IFELSE",
            loc: instr.loc,
        }, options);
    }
    if (instr.$ === "IFNOTREF") {
        types_1.IFNOT.store(b, {
            $: "IFNOT",
            loc: instr.loc,
        }, options);
    }
    if (instr.$ === "IFJMPREF") {
        types_1.IFJMP.store(b, {
            $: "IFJMP",
            loc: instr.loc,
        }, options);
    }
    if (instr.$ === "IFNOTJMPREF") {
        types_1.IFNOTJMP.store(b, {
            $: "IFNOTJMP",
            loc: instr.loc,
        }, options);
    }
};
function compileIf(t, b, options) {
    if (!options.skipRefs) {
        // compile as is
        return false;
    }
    if (t.$ === "IFREF" ||
        t.$ === "IFREFELSE" ||
        t.$ === "IFELSEREF" ||
        t.$ === "IFNOTREF" ||
        t.$ === "IFJMPREF" ||
        t.$ === "IFNOTJMPREF") {
        try {
            const b2 = new builder_1.CodeBuilder();
            // Try to compile, this code may throw an exception if PUSHCONT and IF doesn't fit into a single cell
            compilePushcont(b2, t.arg0, t.loc, options);
            compileNonRefIf(b2, t, options);
            if (b2.bits + b.bits <= builder_1.MAX_CELL_BITS && b2.refs + b.refs <= 4) {
                compilePushcont(b, t.arg0, t.loc, options);
                compileNonRefIf(b, t, options);
                return true;
            }
        }
        catch {
            return false;
        }
    }
    return false;
}
const safeStore = (b, t, isLastInstruction, options) => {
    const inlined = compileIf(t, b, options);
    if (inlined) {
        return false;
    }
    try {
        instr_1.instr.store(b, t, options);
        if (b.bits >= builder_1.MAX_CELL_BITS - (b.isDictionaryCell ? b.offset : 0)) {
            return true;
        }
        if (!isLastInstruction && options.skipRefs) {
            if (b.bits >= builder_1.MAX_CELL_BITS - 8) {
                // we need room for PUSHREF
                return true;
            }
        }
        if (b.refs >= 4 && !isLastInstruction) {
            if (t.$ === "PSEUDO_PUSHREF" && b.refs === 4) {
                // In the case where the compiler itself has set the necessary `ref {}`,
                // we do not try to predict in advance whether there may be an overflow further,
                // since the compiler has already decomposed everything into correct refs
                return false;
            }
            // In case of other instructions that push references, we cannot be sure, so
            // we handle this case explicitly.
            return true;
        }
    }
    catch (error) {
        if (error instanceof Error) {
            if (error.message === "BitBuilder overflow" ||
                error.message === "Too many references") {
                return true;
            }
        }
        throw error;
    }
    return false;
};
//# sourceMappingURL=compile.js.map