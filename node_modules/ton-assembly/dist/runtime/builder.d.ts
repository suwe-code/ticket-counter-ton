import type { Cell } from "@ton/core";
import { Builder } from "@ton/core";
import type { Instr } from "./instr-gen";
import type { Dictionary, DictionaryKeyTypes } from "../dict/Dictionary";
export declare const MAX_CELL_BITS = 1023;
/**
 * Describes an instruction with its offset in the parent `Cell`.
 */
export type InstructionWithOffset = {
    readonly instr: Instr;
    readonly offset: number;
    readonly debugSections: readonly number[];
};
/**
 * Describes a mapping of a single `Cell` to its instructions and sub-mappings.
 *
 * This mapping is crucial for debugging, since in Sandbox logs we only have
 * a hash of the current Cell and instruction offset in it.
 */
export type Mapping = {
    /**
     * The hash of the `Cell` that is being mapped.
     */
    readonly cell: string;
    /**
     * The instructions that are stored in the `Cell`.
     */
    readonly instructions: InstructionWithOffset[];
    /**
     * Instructions can store references to other cells.
     * These references are stored in this array.
     */
    readonly subMappings: readonly Mapping[];
    /**
     * When we serialize a `Dictionary`, we store additional information
     * about the position of the cell in the dictionary Cell.
     */
    readonly dictionaryInfo: readonly DictionaryInfo[];
};
/**
 * When we serialize a `Dictionary`, we store actual Cell data after some prefix.
 * If we want to map Dictionary Cell to its instructions, we need to store
 * information about which Dictionary Cell contains Cell with instructions
 * and its offset in the Dictionary Cell.
 *
 * When we parse Sandbox logs, we have a hash of the Dictionary Cell, but we actually
 * want to get the instructions, so we need this information to map the Dictionary Cell
 * to its instructions.
 */
export type DictionaryInfo = {
    /**
     * The `CodeBuilder` that builds the Dictionary Cell.
     */
    readonly builder: CodeBuilder;
    /**
     * The offset of the Cell with instructions in the Dictionary Cell.
     */
    readonly offset: number;
    /**
     * The `Cell` that contains the instructions.
     */
    readonly childCell: Cell;
};
/**
 * Extended Builder class that stores additional debug information.
 */
export declare class CodeBuilder extends Builder {
    readonly isDictionaryCell: boolean;
    readonly offset: number;
    private readonly instructions;
    private readonly subMappings;
    private readonly dictionaryInfo;
    private debugSectionIds;
    constructor(isDictionaryCell?: boolean, offset?: number);
    storeInstructionPrefix(value: bigint | number, bits: number, instr: Instr): this;
    addImplicitRet(): void;
    build(): [Cell, Mapping];
    clearDebugSectionIds(): this;
    startDebugSection(id: number): this;
    pushMappings(...mappings: Mapping[]): this;
    pushInstructions(...instructions: InstructionWithOffset[]): this;
    getDictionaryInfo(): DictionaryInfo[];
    pushDictionaryInfo(...info: DictionaryInfo[]): this;
    storeRefWithMapping([cell, mapping]: [Cell, Mapping]): this;
    storeDictionaryDirect<K extends DictionaryKeyTypes, V>(dict: Dictionary<K, V>): this;
    canFit(bits: number): boolean;
    reinitFrom(other: CodeBuilder): this;
}
//# sourceMappingURL=builder.d.ts.map